
`timescale 1ns/1ps
// UART Receiver
module uart_rx #(parameter CLK_FREQ=50000000, BAUD=115200)(
    input  wire clk, rst,
    input  wire rx,
    output reg  [7:0] data,
    output reg  valid
);
    localparam DIV = CLK_FREQ/BAUD;
    reg [15:0] cnt;
    reg [3:0]  bitpos;
    reg [9:0]  shift;
    reg        busy;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            cnt<=0; bitpos<=0; busy<=0; valid<=0;
        end else begin
            valid <= 0;
            if (!busy) begin
                if (!rx) begin // start bit
                    busy<=1; cnt<=DIV/2; bitpos<=0; shift<=0;
                end
            end else begin
                if (cnt==DIV-1) begin
                    cnt<=0;
                    shift <= {rx, shift[9:1]};
                    bitpos <= bitpos+1;
                    if (bitpos==9) begin
                        busy<=0;
                        data <= shift[8:1];
                        valid<=1;
                    end
                end else cnt<=cnt+1;
            end
        end
    end
endmodule

// -----------------------------
// UART Transmitter
// -----------------------------
module uart_tx #(parameter CLK_FREQ=50000000, BAUD=115200)(
    input  wire clk, rst,
    input  wire [7:0] data,
    input  wire send,
    output reg  tx,
    output reg  busy
);
    localparam DIV = CLK_FREQ/BAUD;
    reg [15:0] cnt;
    reg [3:0]  bitpos;
    reg [9:0]  shift;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            tx<=1; busy<=0; cnt<=0; bitpos<=0;
        end else begin
            if (!busy && send) begin
                busy<=1;
                shift <= {1'b1, data, 1'b0};
                bitpos<=0;
            end
            if (busy) begin
                if (cnt==DIV-1) begin
                    cnt<=0;
                    tx <= shift[0];
                    shift <= {1'b1, shift[9:1]};
                    bitpos <= bitpos+1;
                    if (bitpos==9) busy<=0;
                end else cnt<=cnt+1;
            end
        end
    end
endmodule

// -----------------------------
// Simple Instruction/Data Memory (4KB)
// -----------------------------
module simple_mem(
    input wire clk,
    input wire [31:0] addr,
    input wire [31:0] wdata,
    input wire we,
    input wire [3:0] wstrb,
    output reg [31:0] rdata
);
    reg [7:0] mem [0:4095];
    integer i;
    initial for(i=0;i<4096;i=i+1) mem[i]=0;

    always @(posedge clk) begin
        if (we) begin
            if (wstrb[0]) mem[addr]   <= wdata[7:0];
            if (wstrb[1]) mem[addr+1] <= wdata[15:8];
            if (wstrb[2]) mem[addr+2] <= wdata[23:16];
            if (wstrb[3]) mem[addr+3] <= wdata[31:24];
        end
        rdata <= {mem[addr+3],mem[addr+2],mem[addr+1],mem[addr]};
    end
endmodule

// -----------------------------
// Minimal RV32I Core (3-stage)
// -----------------------------
module rv32i_core(
    input  wire clk, rst,
    output reg [31:0] imem_addr,
    input  wire [31:0] imem_rdata,
    output reg [31:0] dmem_addr,
    output reg [31:0] dmem_wdata,
    output reg [3:0]  dmem_wstrb,
    output reg        dmem_we,
    input  wire [31:0] dmem_rdata
);
    reg [31:0] pc;
    reg [31:0] regs[0:31];
    integer i;

    // pipeline registers
    reg [31:0] if_instr;
    reg [31:0] id_instr;
    reg [31:0] id_rs1, id_rs2;
    reg [31:0] ex_result;
    reg [4:0]  ex_rd;
    reg        ex_we;

    // IF stage
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            pc<=0; imem_addr<=0; if_instr<=0;
            for(i=0;i<32;i=i+1) regs[i]<=0;
        end else begin
            imem_addr <= pc;
            if_instr <= imem_rdata;
            pc <= pc + 4;
        end
    end

    // ID stage
    wire [6:0] opcode = if_instr[6:0];
    wire [4:0] rs1 = if_instr[19:15];
    wire [4:0] rs2 = if_instr[24:20];
    wire [4:0] rd  = if_instr[11:7];
    wire [31:0] imm_i = {{20{if_instr[31]}}, if_instr[31:20]};

    always @(posedge clk) begin
        id_instr <= if_instr;
        id_rs1 <= regs[rs1];
        id_rs2 <= regs[rs2];
    end

    // EX/WB stage (very minimal: only ADD, ADDI implemented for demo)
    always @(posedge clk) begin
        ex_result <= 0; ex_rd<=0; ex_we<=0;
        dmem_we<=0; dmem_wstrb<=0;
        case(id_instr[6:0])
            7'b0110011: begin // R-type
                if (id_instr[14:12]==3'b000) begin
                    if (id_instr[30]) ex_result <= id_rs1 - id_rs2; // SUB
                    else ex_result <= id_rs1 + id_rs2;             // ADD
                    ex_rd <= id_instr[11:7];
                    ex_we <= 1;
                end
            end
            7'b0010011: begin // I-type
                if (id_instr[14:12]==3'b000) begin
                    ex_result <= id_rs1 + imm_i; // ADDI
                    ex_rd <= id_instr[11:7];
                    ex_we <= 1;
                end
            end
            default: begin end
        endcase
        if (ex_we && ex_rd!=0) regs[ex_rd] <= ex_result;
    end
endmodule

// -----------------------------
// Top-level SoC with UART loader
// -----------------------------
module rv32i_uart_soc(
    input wire clk, rst,
    input wire uart_rx_i,
    output wire uart_tx_o
);
    wire [7:0] rx_data; wire rx_valid;
    uart_rx #(.CLK_FREQ(50000000),.BAUD(115200)) U_RX(
        .clk(clk),.rst(rst),.rx(uart_rx_i),.data(rx_data),.valid(rx_valid)
    );

    wire [7:0] tx_data; wire tx_send; wire tx_busy;
    uart_tx #(.CLK_FREQ(50000000),.BAUD(115200)) U_TX(
        .clk(clk),.rst(rst),.data(tx_data),.send(tx_send),.tx(uart_tx_o),.busy(tx_busy)
    );

    // Memories
    wire [31:0] imem_addr, imem_rdata;
    wire [31:0] dmem_addr, dmem_wdata, dmem_rdata;
    wire [3:0]  dmem_wstrb; wire dmem_we;

    simple_mem IMEM(.clk(clk),.addr(imem_addr),.wdata(0),.we(0),.wstrb(0),.rdata(imem_rdata));
    simple_mem DMEM(.clk(clk),.addr(dmem_addr),.wdata(dmem_wdata),.we(dmem_we),.wstrb(dmem_wstrb),.rdata(dmem_rdata));

    // Core
    rv32i_core CORE(.clk(clk),.rst(rst),
        .imem_addr(imem_addr),.imem_rdata(imem_rdata),
        .dmem_addr(dmem_addr),.dmem_wdata(dmem_wdata),.dmem_wstrb(dmem_wstrb),.dmem_we(dmem_we),
        .dmem_rdata(dmem_rdata)
    );
endmodule
